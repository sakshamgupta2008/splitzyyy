# Firestore Database Schema

## Visual Schema Diagram

```
Firestore Root
│
├── users (collection)
│   └── {userId} (document)
│       ├── uid: string
│       ├── name: string
│       ├── email: string
│       ├── photoURL: string
│       └── createdAt: timestamp
│
└── groups (collection)
    └── {groupId} (document)
        ├── name: string
        ├── joinCode: string (5-digit unique code)
        ├── createdBy: string (userId)
        ├── members: array<string> (array of userIds)
        ├── createdAt: timestamp
        │
        ├── expenses (subcollection)
        │   └── {expenseId} (document)
        │       ├── description: string
        │       ├── totalAmount: number
        │       ├── paidBy: string (userId)
        │       ├── splitAmong: array<string> (array of userIds)
        │       ├── perPersonAmount: number
        │       └── createdAt: timestamp
        │
        └── transactions (subcollection)
            └── {transactionId} (document)
                ├── from: string (userId who owes)
                ├── to: string (userId who is owed)
                ├── amount: number
                ├── expenseId: string (reference to expense)
                └── createdAt: timestamp
```

## Detailed Schema

### Collection: `users`

**Purpose**: Store user profile information

**Document ID**: Firebase Auth UID

**Fields**:

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| uid | string | Firebase Auth UID | Yes |
| name | string | User's display name | Yes |
| email | string | User's email address | Yes |
| photoURL | string | URL to user's profile photo | Yes |
| createdAt | timestamp | Account creation timestamp | Yes |

**Indexes**: None required

**Sample Document**:
```json
{
  "uid": "abc123xyz",
  "name": "John Doe",
  "email": "john@example.com",
  "photoURL": "https://lh3.googleusercontent.com/...",
  "createdAt": "2026-02-13T10:30:00Z"
}
```

---

### Collection: `groups`

**Purpose**: Store group information

**Document ID**: Auto-generated by Firestore

**Fields**:

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| name | string | Group name | Yes |
| joinCode | string | 5-digit unique numeric code | Yes |
| createdBy | string | UID of group creator | Yes |
| members | array<string> | Array of member UIDs | Yes |
| createdAt | timestamp | Group creation timestamp | Yes |

**Indexes**:
- `joinCode` (ascending) - for quick group lookup by code
- `members` (array-contains) - for finding user's groups

**Sample Document**:
```json
{
  "name": "Goa Trip 2026",
  "joinCode": "12345",
  "createdBy": "abc123xyz",
  "members": ["abc123xyz", "def456uvw", "ghi789rst"],
  "createdAt": "2026-02-13T10:30:00Z"
}
```

---

### Subcollection: `groups/{groupId}/expenses`

**Purpose**: Store individual expenses within a group

**Document ID**: Auto-generated by Firestore

**Fields**:

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| description | string | Expense description | Yes |
| totalAmount | number | Total expense amount | Yes |
| paidBy | string | UID of person who paid | Yes |
| splitAmong | array<string> | UIDs to split expense among | Yes |
| perPersonAmount | number | Amount per person (calculated) | Yes |
| createdAt | timestamp | Expense creation timestamp | Yes |

**Calculation**:
```
perPersonAmount = totalAmount / splitAmong.length
```

**Indexes**:
- `createdAt` (descending) - for chronological listing

**Sample Document**:
```json
{
  "description": "Dinner at restaurant",
  "totalAmount": 2000,
  "paidBy": "abc123xyz",
  "splitAmong": ["abc123xyz", "def456uvw", "ghi789rst"],
  "perPersonAmount": 666.67,
  "createdAt": "2026-02-13T20:30:00Z"
}
```

---

### Subcollection: `groups/{groupId}/transactions`

**Purpose**: Track individual debt transactions between users

**Document ID**: Auto-generated by Firestore

**Fields**:

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| from | string | UID of person who owes | Yes |
| to | string | UID of person who is owed | Yes |
| amount | number | Amount owed | Yes |
| expenseId | string | Reference to expense document | Yes |
| createdAt | timestamp | Transaction creation timestamp | Yes |

**Transaction Logic**:
When an expense is created:
- For each member in `splitAmong` (except `paidBy`)
- Create transaction: `from: memberId` → `to: paidBy` with `amount: perPersonAmount`

**Example**:
If Alice pays ₹1000 and splits among Alice, Bob, Charlie, David:
- perPersonAmount = ₹250
- Create transactions:
  - Bob → Alice: ₹250
  - Charlie → Alice: ₹250
  - David → Alice: ₹250

**Indexes**:
- `from` (ascending) - for finding debts user owes
- `to` (ascending) - for finding debts owed to user
- `createdAt` (descending) - for chronological listing

**Sample Document**:
```json
{
  "from": "def456uvw",
  "to": "abc123xyz",
  "amount": 666.67,
  "expenseId": "exp_abc123",
  "createdAt": "2026-02-13T20:30:00Z"
}
```

---

## Data Relationships

### User ↔ Groups
- **Relationship**: Many-to-Many
- **Implementation**: `groups.members` array contains user UIDs
- **Query**: Find user's groups: `where('members', 'array-contains', userId)`

### Group → Expenses
- **Relationship**: One-to-Many
- **Implementation**: Subcollection `groups/{groupId}/expenses`
- **Query**: Get group expenses: `collection('groups/{groupId}/expenses')`

### Expense → Transactions
- **Relationship**: One-to-Many
- **Implementation**: Subcollection `groups/{groupId}/transactions`
- **Link**: `transactions.expenseId` references expense document ID

### User → Transactions
- **Relationship**: Many-to-Many (as debtor and creditor)
- **Query Debts**: `where('from', '==', userId)`
- **Query Credits**: `where('to', '==', userId)`

---

## Balance Calculation Formulas

### Total Paid (by user)
```
SUM(expenses.totalAmount WHERE expenses.paidBy == userId)
```

### Personal Trip Cost (user's share)
```
SUM(expenses.perPersonAmount WHERE userId IN expenses.splitAmong)
```

### You Owe (debts)
```
SUM(transactions.amount WHERE transactions.from == userId)
```

### Others Owe You (credits)
```
SUM(transactions.amount WHERE transactions.to == userId)
```

### Net Balance
```
(Others Owe You) - (You Owe)

If positive: User is owed money
If negative: User owes money
If zero: All settled
```

---

## Security Rules Summary

### Users Collection
- **Read**: Any authenticated user
- **Write**: Only own document

### Groups Collection
- **Create**: Any authenticated user (must include self in members)
- **Read**: Only group members
- **Update**: Only group members
- **Delete**: Only group creator

### Expenses Subcollection
- **Create**: Only group members (must be paidBy)
- **Read**: Only group members
- **Update/Delete**: Only expense creator

### Transactions Subcollection
- **Create**: Only group members (auto-created with expense)
- **Read**: Only group members
- **Delete**: Only involved parties (from or to)

---

## Data Integrity Constraints

### Enforced by Application Logic:

1. **Join Code Uniqueness**
   - Check existing codes before creating group
   - Generate new code if duplicate found

2. **Member Validation**
   - Verify user exists before adding to group
   - Prevent duplicate memberships

3. **Expense Validation**
   - totalAmount > 0
   - splitAmong.length > 0
   - paidBy must be in members array
   - All UIDs in splitAmong must be valid members

4. **Transaction Consistency**
   - Auto-create transactions when expense is added
   - Maintain link to parent expense
   - Amount matches perPersonAmount from expense

5. **Balance Accuracy**
   - Real-time recalculation on data changes
   - Consistent across all clients via Firestore listeners

---

## Query Patterns

### Common Queries:

1. **Get User's Groups**
```javascript
query(collection(db, 'groups'), 
      where('members', 'array-contains', userId))
```

2. **Find Group by Join Code**
```javascript
query(collection(db, 'groups'), 
      where('joinCode', '==', code))
```

3. **Get Group Expenses (Recent First)**
```javascript
query(collection(db, 'groups', groupId, 'expenses'),
      orderBy('createdAt', 'desc'))
```

4. **Get User's Debts in Group**
```javascript
query(collection(db, 'groups', groupId, 'transactions'),
      where('from', '==', userId))
```

5. **Get User's Credits in Group**
```javascript
query(collection(db, 'groups', groupId, 'transactions'),
      where('to', '==', userId))
```

---

## Scalability Considerations

### Current Design:
- ✅ Supports multiple groups per user
- ✅ Unlimited expenses per group
- ✅ Real-time updates across clients
- ✅ Efficient queries with proper indexing

### Limitations:
- Members array limited to ~1000 (Firestore array size limit)
- For large groups, consider restructuring with separate membership collection

### Optimization Tips:
- Use Firestore listeners for real-time updates
- Cache frequently accessed data
- Paginate expense lists for groups with 100+ expenses
- Implement compound queries for complex filters

---

## Migration Strategy

If schema changes are needed:

1. **Version the schema** in code
2. **Create migration scripts** for existing data
3. **Support backward compatibility** during transition
4. **Update security rules** to match new schema
5. **Test thoroughly** before production deployment

---

This schema is designed for clarity, efficiency, and scalability while maintaining data integrity and security.
